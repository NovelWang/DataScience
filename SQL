1. USE SQL to create a histogram (distribution of a column)

First, we need to define the # of bins and calculate the min, max, and the size of bucket:
For example, if we define the # of bins to be 10:

SELECT (max(open) - min(open)+1)/10.00 as bucket_size, max(open), min(open)
FROM tutorial.aapl_historical_stock_price

OUTPUT:
-70.241  702.41  0

Then we need to assign each row to the bucket from 0 to 9 using floor().
SELECT floor(open-0)/70.341, COUNT(*) as num_of_observations
FROM tutorial.aapl_historical_stock_price
GROUP BY 1
ORDER BY 1



2. Use SQL to find the median.
1) if using window function -- find the 50th percentile
SELECT  percentile_cont(0.5) WITHIN GROUP (ORDER BY open) as median
FROM tutorial.aapl_historical_stock_price


2) if using window function rank()
SELECT max(rank_open)
FROM 
      (SELECT id, open, CASE WHEN open is NULL THEN NULL ELSE RANK() OVER (ORDER BY open) END as rank_open
      FROM tutorial.aapl_historical_stock_price
      WHERE open IS NOT NULL
      ORDER BY 3 DESC) sub

--Note that RANK() will count NULL as unlimitedly large.


3) if using self-join
SELECT *
FROM
      (SELECT a.open, COUNT(b.open) as rank_open
      FROM tutorial.aapl_historical_stock_price a
      JOIN tutorial.aapl_historical_stock_price b
      ON b.open<a.open OR (a.open = b.open AND b.id <= a.id)
      GROUP BY a.open, a.id
      ORDER BY rank_open DESC) sub
WHERE rank_open = 3542/2


3. Check the questions here:
https://github.com/joshualande/joshualande.github.io/blob/master/_drafts/2014-02-04-challening-sql-queries.md
1). For each region, find the minimum surface area for countries that are in the top five for best life expectancy.

     SELECT min(b.surface_area),b.region
     FROM
            (SELECT code
            FROM country
            ORDER BY life_exp DESC LIMIT 5) a
      JOIN country b
      On a.code = b.code
      GROUP by b.region

2). Find the top ten countries with the most languages. 
Return the full country names as well as the number of shared languages.
Sort in descending order by the number of shared lanuages.

SELECT sub.country_code, c.name, sub.num_lan
FROM
      (SELECT country_code, COUNT(language) as num_lan
      FROM country_language
      GROUP BY country_code
      ORDER BY num_lan DESC
      LIMIT 10) sub
JOIN country c
ON sub.country_code = c.code
ORDER BY sub.num_lan DESC

3). Do a histogram on life_expectancy
SELECT floor(life_expectancy/10) as bin_seq, COUNT(code)
FROM country
GROUP BY 1



4. Check the questions here:
https://github.com/joshualande/joshualande.github.io/blob/master/_drafts/2014-06-07-analytics-sql.md

For each user in the last month, compute the number of days that the user logged in.
Next, for each rolling 30 day period, compute the number of login days.

SELECT a.benchmark, b.user_id, COUNT(DISTINCT b.date_id)
FROM
    (SELECT DISTINCT date_id as benchmark
    FROM engagement) a
JOIN engagement b
ON b.date_id< a. benchmark AND b.date_id >= a.benchmark - interval '1 month'
WHERE action_id = 'profile'
GROUP BY 1, 2

OR using window function:

SELECT user_id, day, 
COUNT(day) OVER (PARTITION BY user_id ORDER BY day ROWS BETWEEN 10 preceding AND current row) as num_login
FROM
(SELECT DISTINCT DATE_TRUNC('day', occurred_at) as day, user_id
FROM tutorial.yammer_events
ORDER BY 1) sub


5. Stanford Lagunita --highschooler, friend, likes
PART I. SOCIAL NETWORK QUERIES

Q1. Find the names of all students who are friends with someone named Gabriel. (EASY)
SELECT h1.name
FROM friend f
JOIN highschooler h1, highschooler h2
ON f.ID1 = h1.ID
AND f.ID2 = h2.ID
WHERE h2.name = 'Gabriel'


Q2. For every student who likes someone 2 or more grades younger than themselves,
return that student's name and grade, and the name and grade of the student they like. (EASY)
SELECT h1.name, h1.grade, h2.name, h2.grade
FROM likes l
JOIN highschooler h1, highschooler h2
ON l.ID1 = h1.ID AND l.ID2 = h2.ID
WHERE h1.grade - h2.grade >=2



Q3. For every pair of students who both like each other, 
return the name and grade of both students. 
Include each pair only once, with the two names in alphabetical order. (MEDIUM)

SELECT DISTINCT h1.name, h1.grade, h2.name, h2.grade
FROM likes l1, highschooler h1
JOIN likes l2, highschooler h2
ON l1.ID1 = l2.ID2
AND l1.ID2 = l2.ID1
AND l1.ID1 = h1.ID
AND l1.ID2 = h2.ID
AND h1.name< h2.name
ORDER BY h1.name

Q4. Find all students who do not appear in the Likes table (as a student who likes or is liked) 
and return their names and grades. Sort by grade, then by name within each grade. (EASY)
SELECT h.name, h.grade
FROM highschooler h
LEFT JOIN likes l
ON h.ID = l.ID1
OR h.ID = l.ID2
WHERE l.ID1 IS NULL AND l.ID2 IS NULL
ORDER BY h.grade, h.name

Q5. For every situation where student A likes student B, but we have no information about whom B likes 
(that is, B does not appear as an ID1 in the Likes table), return A and B's names and grades. (EASY)
SELECT h1.name, h1.grade, h2.name, h2.grade
FROM
(SELECT l1.ID1, l1.ID2
FROM likes l1
LEFT JOIN likes l2
ON l1.ID2 = l2.ID1
WHERE l2.ID1 IS NULL) sub
JOIN highschooler h1, highschooler h2
ON sub.ID1 = h1.ID AND sub.ID2 = h2.ID

Q6. Find names and grades of students who only have friends in the same grade.
Return the result sorted by grade, then by name within each grade. (MEDIUM)

SELECT h.name, h.grade
FROM
      (SELECT DISTINCT f.ID1
      FROM friend f
      WHERE f.ID1 NOT IN
                        (SELECT DISTINCT f.ID1
                        FROM friend f
                        JOIN highschooler h1, highschooler h2
                        ON f.ID1 = h1.ID AND f.ID2 = h2.ID 
                        WHERE h1.grade!=h2.grade)
      ) sub
JOIN highschooler h
ON sub.ID1 = h.ID
ORDER BY h.grade, h.name




Q7. For each student A who likes a student B where the two are not friends,
find if they have a friend C in common (who can introduce them!). 
For all such trios, return the name and grade of A, B, and C. (medium)

        SELECT h1.name, h1.grade, h2.name, h2.grade,h3.name, h3.grade
        FROM
        (SELECT DISTINCT a.*
        FROM
        (SELECT l.ID1 as A, f1.ID2 as A_f, l.ID2 as B, f2.ID2 as B_f
        FROM likes l
        JOIN friend f1, friend f2
        ON l.ID1 = f1.ID1 AND l.ID2 = f2.ID1
        WHERE A_f = B_f) a
        LEFT JOIN friend f
        ON a.A = f.ID1 AND a.B = f.ID2
        WHERE f.ID1 IS NULL) sub 
        JOIN highschooler h1, highschooler h2, highschooler h3
        ON sub.A = h1.ID AND sub.B = h2.ID AND sub.B_f = h3.ID

 
Q8. Find the difference between the number of students in the school and the number of different first names. (EASY)
SELECT COUNT(*) - COUNT(DISTINCT name)
FROM highschooler


Q9. Find the name and grade of all students who are liked by more than one other student. 

SELECT h.name, h.grade
(SELECT ID2, COUNT(ID1) as num_fans
FROM likes
GROUP BY ID2
HAVING num_fans >=2) sub
JOIN highschooler h
ON sub.ID2 = h.ID


PART II. SOCIAL NETWORK QUERIES EXTRAS


PART III. SQL Social-Network Modification Exercises




